
shinyServer(function(input, output, session) {

  # Funciones Utilitarias ---------------------------------------------------------------------------------------------------

  # Crea una tabla dependiendo de los datos ingresados
  renderizar.tabla.datos <- function(data, editable = TRUE, extensions = c("Buttons"), dom = "Bfrtip", pageLength = 5, buttons = T, filename = NA, scrollY = "33vh") {
    size <- nrow(data)
    data <- head(data, n = 100)
    if (buttons) {
      buttons <- list(list(extend = "csv", filename = filename, text = "Descargar"))
    } else {
      buttons <- NULL
    }
    nombre.columnas <- c("ID", colnames(data))
    tipo.columnas <- c("", sapply(
      colnames(data),
      function(i) ifelse(class(data[, i]) %in% c("numeric", "integer"), "Numérico", "Categórico")
    ))

    sketch <- htmltools::withTags(table(
      tableHeader(nombre.columnas),
      tableFooter(tipo.columnas)
    ))

    return(DT::datatable(data,
                         selection = "none", editable = editable, container = sketch, extensions = extensions,
                         options = list(dom = dom,
                                        pageLength = pageLength,
                                        buttons = buttons,
                                        scrollY = scrollY,
                                        language = list(
                                          info = paste('_START_ to _END_ of _TOTAL_ entries (real size: ',size,')') ))
    ))
  }

  # Acualiza las distintas tablas
  actualizar.tabla <- function(x = c("datos", "datos.aprendizaje", "datos.prueba")) {
    if (any("datos" %in% x)) { # Cambia la tabla de datos
      output$contents <- DT::renderDT(renderizar.tabla.datos(datos,
                                                             editable = T,
                                                             pageLength = 10,
                                                             buttons = T,
                                                             filename = "datos"),
                                      server = F)
    }

    if (any("datos.aprendizaje" %in% x)) { # Cambia la tabla de datos de aprendizaje
      output$contentsAprend <- DT::renderDT(renderizar.tabla.datos(datos.aprendizaje,
                                                                   editable = T,
                                                                   pageLength = 5,
                                                                   buttons = T,
                                                                   filename = "datos.aprendizaje",
                                                                   scrollY = "15vh"),
                                            server = F)
    }

    if (any("datos.prueba" %in% x)) { # Cambia la tabla de datos de prueba
      output$contentsPrueba <- DT::renderDT(renderizar.tabla.datos(datos.prueba,
                                                                   editable = T,
                                                                   pageLength = 5,
                                                                   buttons = T,
                                                                   filename = "datos.prueba",
                                                                   scrollY = "15vh"),
                                            server = F)
    }
  }

  # Cierra un menu segun su tabName
  close.menu <- function(tabname = NA, valor = T) {
    select <- paste0("a[href^='#shiny-tab-", tabname, "']")
    if (valor) {
      shinyjs::hide(selector = "ul.menu-open")
      shinyjs::disable(selector = select)
    } else {
      shinyjs::enable(selector = select)
    }
  }

  # Validacion comun para todos los modelos
  validar.datos <- function(print = TRUE) {
    # Validaciones
    if (is.null(variable.predecir) & print) {
      showNotification("Tiene que seleccionar una variable a predecir", duration = 10, type = "error")
    }
    if (is.null(datos) & print) {
      showNotification("Tiene que ingresar datos", duration = 10, type = "error")
    }
    if (is.null(datos.aprendizaje) & print) {
      showNotification("Tiene que crear los datos de aprendizaje y de prueba", duration = 10, type = "error")
    }
    return(!is.null(datos) & !is.null(variable.predecir) & !is.null(datos.aprendizaje))
  }

  # Crea la tabla de comparacion entre prediccion y datos reales (datos de prueba)
  obj.predic <- function(predic.var = NULL) {
    real <- as.character(datos.prueba[, variable.predecir])
    predi <- as.character(predic.var)
    df <- cbind(real, predi, ifelse(real == predi,
                                    rep("<span style='color:green'><b>Acertó</b></span>", length(real)),
                                    rep("<span style='color:red'><b>Falló</b></span>", length(real))
    ))
    colnames(df) <- c("Datos Reales", "Predicción", " ")
    sketch <- htmltools::withTags(table(
      tableHeader(c("Datos Reales", "Predicción", " "))
    ))
    return(DT::datatable(df,
                         selection = "none",
                         editable = FALSE,
                         escape = FALSE,
                         container = sketch,
                         extensions = c("Responsive"),
                         options = list(dom = "frtip", pageLength = 10)
    ))
  }

  # Mostar o ocultar los indices
  indices.g <- function(id = "knn", mc = NA) {
    if (!is.null(mc)) {
      shinyjs::show(paste0(id, "PrecGlob"))
      shinyjs::show(paste0(id, "ErrorGlob"))
    } else {
      shinyjs::hide(paste0(id, "PrecGlob"))
      shinyjs::hide(paste0(id, "ErrorGlob"))
    }
  }

  # Genera los gauges
  fill.gauges <- function(ids, titulos, indices) {
    for (i in 1:length(ids)) {
      eval(parse(text = new.gauge(ids[i], indices[[i]], titulos[i])))
    }
  }

  # Grafica un error de datos faltantes
  error.plot.tipos.variables <- function(num = T){
    if(num){
      img <- raster::stack("www/errorNumericas.png")
    }else{
      img <- raster::stack("www/errorCategoricas.png")
    }
    raster::plotRGB(img)
  }

  # Concatena y ejecuta un string como codigo
  exe <- function(...){
    eval(parse(text = paste0(...)))
  }

  # Configuraciones iniciales -----------------------------------------------------------------------------------------------

  source("global.R", local = T)
  options(shiny.maxRequestSize = 200 * 1024^2, DT.options = list(aLengthMenu = c(10, 30, 50), iDisplayLength = 10, scrollX = TRUE))
  shinyjs::disable(selector = 'a[href^="#shiny-tab-parte1"]')
  shinyjs::disable(selector = 'a[href^="#shiny-tab-parte2"]')
  shinyjs::disable(selector = 'a[href^="#shiny-tab-comparar"]')
  shinyjs::disable(selector = 'a[href^="#shiny-tab-poderPred]')
  shinyjs::disable(selector = 'a[href^="#shiny-tab-parte1"]')
  actualizar.tabla()
  isolate(eval(parse(text = default.func.num())))
  isolate(eval(parse(text = default.func.cat())))
  updateAceEditor(session, "fieldCodeResum", value = cod.resum())
  updateAceEditor(session, "fieldModelCor", value = modelo.cor())
  updateAceEditor(session, "fieldFuncNum", value = default.func.num())
  updateAceEditor(session, "fieldFuncCat", value = def.code.cat())
  close.menu("predNuevos",F)

  # Valores Reactivos -------------------------------------------------------------------------------------------------------

  updatePlot <- reactiveValues(
    calc.normal = default.calc.normal(), normal = NULL, disp = NULL,
    cor = NULL, dya.num = NULL, dya.cat = NULL, poder.pred = NULL,
    poder.cat = NULL, poder.num = NULL, poder.dens = NULL, roc = FALSE,
    svm.graf = NULL
  )

  disp.ranges <- reactiveValues(x = NULL, y = NULL)

  # Pagina de Cargar y Transformar Datos ------------------------------------------------------------------------------------

  # Carga datos
  cargar.datos <- function(codigo.carga = "") {
    tryCatch({
      isolate(eval(parse(text = codigo.carga)))
      if(ncol(datos) <= 1) {
        showNotification(paste0("Error al cargar los Datos: Revisar separadores"), duration = 10, type = "error")
        return(NULL)
      }
      new.report()
    },
    error = function(e) {
      showNotification(paste0("Error al cargar los Datos: ", e), duration = 10, type = "error")
      datos <<- NULL
      datos.originales <<- NULL
      return(NULL)
    }
    )
  }

  # Limpiado datos
  limpiar.datos <- function() {
    if (any(is.na(datos))) {
      tryCatch({
        codigo.na <- paste0(code.NA(deleteNA = input$deleteNA), "\n", "datos <<- datos.originales")
        isolate(eval(parse(text = codigo.na)))
        insert.report("na.delete",paste0("\n# Imputación de Datos\n```{r}\n",codigo.na,"\nhead(datos)\nstr(datos)\n```"))
      }, error = function(e) {
        showNotification(paste0("Error al eliminar NAs: ", e), duration = 10, type = "error")
        datos <<- NULL
        datos.originales <<- NULL
        return(NULL)
      })
    } else {
      codigo.na <- ""
    }
    return(codigo.na)
  }

  # Transforma los datos
  transformar.datos <- function() {
    var.noactivas <- c()
    code.res <- "datos <<- datos.originales \n"
    for (var in colnames(datos.originales)) {
      if (input[[paste0("box", var, contador)]]) {
        if (input[[paste0("sel", var, contador)]] == "categorico" & class(datos.originales[, var]) %in% c("numeric", "integer")) {
          code.res <- paste0(code.res, code.trans(var, "categorico"), "\n")
        }
        if (input[[paste0("sel", var, contador)]] == "numerico" & !(class(datos.originales[, var]) %in% c("numeric", "integer"))) {
          code.res <- paste0(code.res, code.trans(var, "numerico"), "\n")
        }
        if (input[[paste0("sel", var, contador)]] == "disyuntivo") {
          code.res <- paste0(code.res, code.trans(var, "disyuntivo"), "\n")
        }
      } else {
        var.noactivas <- c(var.noactivas, var)
      }
    }

    isolate(eval(parse(text = code.res)))
    if (length(var.noactivas) > 0) {
      isolate(eval(parse(text = code.desactivar(var.noactivas))))
    }

    code.res <- paste0(code.res, "\n", code.desactivar(var.noactivas))
    new.secction.report()
    insert.report("transformar.datos",paste0("# Transformando Datos\n```{r}\n",code.res,"\nstr(datos)\n```"))
    return(code.res)
  }

  # Actualizar los distintos selectores
  acualizar.selecctores <- function() {
    updateSelectizeInput(session, "sel.normal", choices = colnames.empty(var.numericas(datos)))
    updateSelectizeInput(session, "select.var", choices = colnames.empty(var.numericas(datos)))
    updateSelectInput(session, "sel.distribucion.num", choices = colnames.empty(var.numericas(datos)))
    updateSelectInput(session, "sel.distribucion.cat", choices = colnames.empty(var.categoricas(datos)))
    updateSelectInput(session, "sel.resumen", choices = colnames.empty(datos))
    updateSelectInput(session, "sel.predic.var", choices = rev(colnames.empty(var.categoricas(datos))))
  }

  # Crea las correlaciones
  ejecutar.modelo.cor <- function() {
    tryCatch({
      isolate(eval(parse(text = modelo.cor())))
      output$txtcor <- renderPrint(print(correlacion))
    }, error = function(e) {
      return(datos <- NULL)
    })
  }

  # Borra los datos de los modelos
  borrar.modelos <- function(flag.datos = TRUE) {

    # -------------------  DATA ------------------------ #

    if (flag.datos) {
      datos.prueba <<- NULL
      datos.aprendizaje <<- NULL
      variable.predecir <<- NULL
    }

    # -------------------  Modelos ------------------------ #

    MCs <<- list()
    areas <<- list()
    scores <<- list()

    #Se usan como condicion para el codigo js
    output$txtknn <- renderPrint(invisible(""))
    output$txtSvm <- renderPrint(invisible(""))
    output$txtDt <- renderPrint(invisible(""))
    output$txtRf <- renderPrint(invisible(""))
    output$txtBoosting <- renderPrint(invisible(""))
    updateSelectInput(session,"kernel.knn",selected = "optimal")
  }

  # Cunado es precionado el boton de cargar datos
  observeEvent(input$loadButton, {
    codigo.carga <- code.carga(
      nombre.filas = input$rowname, ruta = input$file1$datapath,
      separador = input$sep, sep.decimal = input$dec, encabezado = input$header
    )

    # Carga los datos
    cargar.datos(codigo.carga)

    # Limpia los datos
    codigo.na <- limpiar.datos()

    # Actualiza el codigo
    updateAceEditor(session, "fieldCodeData", value = paste0(codigo.carga, "\n", codigo.na))

    # Actualiza los selectores que dependen de los datos
    acualizar.selecctores()

    # modelo correlacion
    ejecutar.modelo.cor()

    # borra los datos de modelos
    borrar.modelos()

    # Cierra o abre lo s menus los menus
    close.menu("parte1", is.null(datos))
    close.menu("parte2", is.null(datos.aprendizaje))
    close.menu("comparar", is.null(datos.aprendizaje))
    close.menu("poderPred", is.null(datos.aprendizaje))

    # Cambia las tablas de datos
    actualizar.tabla()
  }, priority = 4)

  # Cunado es precionado el boton de transformar datos
  observeEvent(input$transButton, {
    # transforma los datos
    code.res <- transformar.datos()

    # Actualiza el codigo
    updateAceEditor(session, "fieldCodeTrans", value = code.res)

    # Actualiza los selectores que dependen de los datos
    acualizar.selecctores()

    # modelo correlacion
    ejecutar.modelo.cor()

    # borra los datos de modelos
    borrar.modelos()

    # Cierra o abre lo s menus los menus
    close.menu("parte1", is.null(datos))
    close.menu("parte2", is.null(datos.aprendizaje))
    close.menu("comparar", is.null(datos.aprendizaje))
    close.menu("poderPred", is.null(datos.aprendizaje))

    # Cambia las tablas de datos
    actualizar.tabla()
  }, priority = 4)

  # Crea los select box del panel de trasnformar datos
  update.trans <- eventReactive(input$loadButton, {
    contador <<- contador + 1
    if (!is.null(datos) && ncol(datos) > 0) {
      res <- data.frame(Variables = colnames(datos), Tipo = c(1:ncol(datos)), Activa = c(1:ncol(datos)))
      res$Tipo <- sapply(colnames(datos), function(i) paste0(
        '<select id="sel', i, contador, '"> <option value="categorico">Categórico</option>
        <option value="numerico" ', ifelse(class(datos[, i]) %in% c("numeric", "integer"),
                                           ' selected="selected"', ""
      ),
      '>Numérico</option> <option value="disyuntivo">Disyuntivo</option> </select>'
      ))
      res$Activa <- sapply(colnames(datos), function(i) paste0('<input type="checkbox" id="box', i, contador, '" checked/>'))
    } else {
      res <- as.data.frame(NULL)
      showNotification("Tiene que cargar los datos", duration = 10, type = "error")
    }
    return(res)
  })

  # Cambia la tabla de con las opciones del panel de transformar
  output$transData <- DT::renderDataTable(update.trans(),
                                          escape = FALSE, selection = "none", server = FALSE,
                                          options = list(dom = "t", paging = FALSE, ordering = FALSE, scrollY = "45vh"), rownames = F,
                                          callback = JS("table.rows().every(function(i, tab, row) {
                                                        var $this = $(this.node());
                                                        $this.attr('id', this.data()[0]);
                                                        $this.addClass('shiny-input-checkbox');});
                                                        Shiny.unbindAll(table.table().node());
                                                        Shiny.bindAll(table.table().node());"))

  # Pagina de Segmentar Datos -----------------------------------------------------------------------------------------------

  # Crea los datos de aprendizaje y prueba
  segmentar.datos <- function(codigo) {
    tryCatch({
      isolate(eval(parse(text = codigo)))
      updateAceEditor(session, "fieldCodeSegment", value = codigo)
    }, error = function(e) {
      showNotification(paste0("Error al dividir los datos : ", e), duration = 15, type = "error")
    })
  }

  # Actualiza los selecctores relacionados con los datos de prueba y aprendizaje
  acualizar.selecctores.seg <- function() {
    nombres <- colnames.empty(var.numericas(datos))
    updateSelectizeInput(session, "select.var.svm.plot", choices = nombres)
    choices <- as.character(unique(datos[, variable.predecir]))
    updateSelectInput(session, "roc.sel", choices = choices, selected = choices[1])
    cat.sin.pred <- colnames.empty(var.categoricas(datos))
    cat.sin.pred <- cat.sin.pred[cat.sin.pred != input$sel.predic.var]
    updateSelectInput(session, "sel.distribucion.poder", choices = cat.sin.pred)
    updateSelectInput(session, "sel.density.poder", choices = nombres)
    updateAceEditor(session, "fieldCodePoderPred", value = plot.code.poder.pred(variable.predecir))
    updatePlot$poder.pred <<- plot.code.poder.pred(variable.predecir)
  }

  # Segmenta los datos en aprendizaje y prueba
  observeEvent(input$segmentButton, {
    if (input$sel.predic.var != "") {
      codigo <- particion.code(
        "datos", input$segmentacionDatosA,
        input$sel.predic.var,
        input$semilla,
        input$permitir.semilla)
      semilla <<- input$permitir.semilla

      knn.stop.excu <<- FALSE
      rf.stop.excu <<- FALSE

      segmentar.datos(codigo)

      new.secction.report()
      insert.report("segmentar.datos",paste0("\n# Datos de Aprendizaje\n```{r}\n",codigo,
                                             "\nhead(datos.aprendizaje)\n```\n\n# Datos de Prueba\n```{r}\nhead(datos.prueba)\n```\n"))

      acualizar.selecctores.seg()

      # borra los datos de modelos
      borrar.modelos(FALSE)

      # Cambia los codigos de los modelos
      default.codigo.knn(k.def = TRUE)
      default.codigo.svm()
      default.codigo.dt()
      deafult.codigo.rf(rf.def = TRUE)
      deault.codigo.boosting()
    } else {
      showNotification("Tiene que seleccionar una variable a predecir", duration = 15, type = "error")
    }

    # Cierre o abre el menu
    close.menu("parte2", is.null(datos.aprendizaje))
    close.menu("comparar", is.null(datos.aprendizaje))
    close.menu("poderPred", is.null(datos.aprendizaje))
    # Cambia las tablas de aprendizaje y de prueba
    actualizar.tabla(c("datos.aprendizaje", "datos.prueba"))
  },priority = 5)

  # Habilitada o deshabilitada la semilla
  observeEvent(input$permitir.semilla, {
    if (input$permitir.semilla) {
      shinyjs::enable("semilla")
    } else {
      shinyjs::disable("semilla")
    }
  })

  # Cuando cambia la barra de proporcion de datos de prueba (Segmentar Datos)
  observeEvent(input$segmentacionDatosA, {
    updateSliderInput(session, "segmentacionDatosT", value = 100 - input$segmentacionDatosA)
  })

  # Cuando cambia la barra de proporcion de datos de aprendizaje (Segmentar Datos)
  observeEvent(input$segmentacionDatosT, {
    updateSliderInput(session, "segmentacionDatosA", value = 100 - input$segmentacionDatosT)
  })

  # Pagina de Resumen -------------------------------------------------------------------------------------------------------

  # Cambia la tabla con el summary en la pagina de resumen
  output$resumen.completo <- DT::renderDataTable(obj.resum(), options = list(dom = "ft", scrollX = TRUE), rownames = F)

  # Se crea una tabla summary
  obj.resum <- eventReactive(c(input$loadButton, input$transButton), {
    insert.report("resumen" ,c(paste0("\n## Resumen Numérico \n```{r} \nsummary(datos) \n```")))
    data.frame(unclass(summary(datos)), check.names = FALSE, stringsAsFactors = FALSE)
  })

  # Cambia los cuadros de summary por varibale
  output$resumen <- renderUI({
    if (input$sel.resumen %in% colnames(var.numericas(datos))) {
      HTML(resumen.numerico(datos, input$sel.resumen))
    } else {
      HTML(resumen.categorico(datos, input$sel.resumen))
    }
  })

  # Pagina del Test de Normalidad -------------------------------------------------------------------------------------------

  # Hace el grafico de la pagina de test de normalidad
  observeEvent(c(input$loadButton, input$transButton), {
    output$plot.normal <- renderPlot({
      tryCatch({
        cod.normal <<- updatePlot$normal
        res <- isolate(eval(parse(text = cod.normal)))
        updateAceEditor(session, "fieldCodeNormal", value = cod.normal)
        insert.report(paste0("normalidad.", input$sel.normal),paste0("## Test de Normalidad \n```{r}\n", cod.normal, "\n```"))
        return(res)
      }, error = function(e) {
        if (ncol(var.numericas(datos)) == 0){
          error.plot.tipos.variables(T)
        }else{
          showNotification(paste0("ERROR AL GENERAR TEST DE NORMALIDAD: ", e), duration = 10, type = "error")
          return(NULL)
        }
      })
    })
  })

  # Ejecuta el codigo en el campo del codigo
  observeEvent(input$run.normal, {
    updatePlot$normal <- input$fieldCodeNormal
  })

  # Ejecuta el codigo cuando cambian los parametros
  observeEvent(c(input$sel.normal, input$col.normal), {
    updatePlot$normal <- default.normal(data = "datos", vars = input$sel.normal, color = input$col.normal)
  })

  # Hace la tabla comparativa de la pagina de test de normalidad
  observeEvent(c(input$loadButton, input$transButton), {
    output$calculo.normal <- DT::renderDataTable({
      tryCatch({
        codigo <- updatePlot$calc.normal
        res <- isolate(eval(parse(text = codigo)))
        updateAceEditor(session, "fieldCalcNormal", value = codigo)
        return(res)
      }, error = function(e) {
        showNotification(paste0("ERROR AL CALCULAR TEST DE NORMALIDAD: ", e), duration = 10, type = "error")
        return(NULL)
      })
    })
  })

  # Ejecuta la tabla comparativa
  observeEvent(input$run.calc.normal, {
    updatePlot$calc.normal <- input$fieldCalcNormal
  })

  # Pagina de Dispersion ----------------------------------------------------------------------------------------------------

  # Hace el grafico de dispersion
  observeEvent(c(input$loadButton, input$transButton), {
    output$plot.disp <- renderPlot({
      tryCatch({
        cod.disp <<- updatePlot$disp
        updateAceEditor(session, "fieldCodeDisp", value = cod.disp)
        res <- isolate(eval(parse(text = cod.disp)))
        if (!is.null(cod.disp) && cod.disp != "") {
          insert.report(paste0("dispersion.", paste(input$select.var, collapse = ".")),
                        paste0("## Dispersión \n```{r}\n", cod.disp, "\n```"))
        }
        return(res)
      }, error = function(e) {
        showNotification(paste0("ERROR AL GENERAR DISPERSIÓN: ", e), duration = 10, type = "error")
        return(NULL)
      })
    })
  })

  #Hace el grafico del zoom
  output$plot.disp.zoom <- renderPlot({
    tryCatch({
      cod.disp <<- updatePlot$disp
      res <- isolate(eval(parse(text = cod.disp)))
      res <- res + coord_cartesian(xlim = disp.ranges$x, ylim = disp.ranges$y, expand = FALSE)
      return(res)
    }, error = function(e) {
      return(NULL)
    })
  })

  #Hace la tabal de con los valores de disperción.
  output$mostrar.disp.zoom <- DT::renderDataTable({
    tryCatch({
      return(brushedPoints(datos[, input$select.var], input$zoom.disp))
    }, error = function(e) {
      return(NULL)
    })
  }, options = list(dom = 't', scrollX = TRUE, scrollY = "20vh", pageLength = nrow(datos)))

  # Si se selecciona un area de zoom
  observe({
    brush <- input$zoom.disp
    if (!is.null(brush)) {
      disp.ranges$x <- c(brush$xmin, brush$xmax)
      disp.ranges$y <- c(brush$ymin, brush$ymax)

    } else {
      disp.ranges$x <- NULL
      disp.ranges$y <- NULL
    }
  })

  # Ejecuta el codigo del grafico
  observeEvent(input$run.disp, {
    updatePlot$disp <- input$fieldCodeDisp
  })

  # Ejecuta el codigo cuando cambian los parametros
  observeEvent(c(input$select.var, input$col.disp), {
    if (length(input$select.var) < 2) {
      updatePlot$disp <- ""
    } else {
      updatePlot$disp <<- default.disp(data = "datos", vars = input$select.var, color = input$col.disp)
    }
  })

  # Pagina de Distribucion --------------------------------------------------------------------------------------------------

  # Hace el grafico de Distribucion numerico
  observeEvent(c(input$loadButton, input$transButton), {
    output$plot.num <- renderPlot({
      tryCatch({
        cod.dya.num <<- updatePlot$dya.num
        res <- isolate(eval(parse(text = cod.dya.num)))
        updateAceEditor(session, "fieldCodeNum", value = cod.dya.num)
        insert.report(paste0("dya.num.", input$sel.distribucion.num),
                      paste0("## Distribución y atipicidad \n```{r}\n", cod.dya.num,"\n```"))
        return(res)
      }, error = function(e) {
        if (ncol(var.numericas(datos)) == 0){
          error.plot.tipos.variables(T)
        }else{
          showNotification(paste0("ERROR: ", e), duration = 10, type = "error")
          return(NULL)
        }
      })
    })
  })

  # Ejecuta el codigo del grafico numerico
  observeEvent(input$run.dya.num, {
    updatePlot$dya.num <- input$fieldCodeNum
  })

  # Ejecuta el codigo cuando cambian los parametros
  observeEvent(c(input$sel.distribucion.num, input$col.dist), {
    updatePlot$dya.num <<- def.code.num(
      data = "datos", color = paste0("'", input$col.dist, "'"),
      variable = paste0("'", input$sel.distribucion.num, "'")
    )
  })

  # Crea la tabla de atipicos
  output$mostrar.atipicos <- DT::renderDataTable({
    tryCatch({
      atipicos <- boxplot.stats(datos[, input$sel.distribucion.num])
      datos <- datos[datos[, input$sel.distribucion.num] %in% atipicos$out, input$sel.distribucion.num, drop = F]
      return(datos[order(datos[, input$sel.distribucion.num]), , drop = F])
    },error = function(e){
      return(data.frame())
    })
  }, options = list(dom = "t", scrollX = TRUE, scrollY = "10vh"))

  # Hace el grafico de Distribucion categorico
  observeEvent(c(input$loadButton, input$transButton), {
    output$plot.cat <- renderPlot({
      tryCatch({
        cod.dya.cat <<- updatePlot$dya.cat
        res <- isolate(eval(parse(text = cod.dya.cat)))
        updateAceEditor(session, "fieldCodeCat", value = cod.dya.cat)
        insert.report(paste0("dya.cat.", input$sel.distribucion.cat),
                      paste0("## Distribución \n```{r}\n", cod.dya.cat, "\n```"))
        return(res)
      }, error = function(e) {
        if (ncol(var.categoricas(datos)) == 0){
          error.plot.tipos.variables(F)
        }else{
          showNotification(paste0("ERROR: ", e), duration = 10, type = "error")
          return(NULL)
        }
      })
    })
  })

  # Ejecuta el codigo del grafico categorico
  observeEvent(input$run.dya.cat, {
    updatePlot$dya.cat <- input$fieldCodeCat
  })

  # Ejecuta el codigo cuando cambian los parametros
  observeEvent(input$sel.distribucion.cat, {
    updatePlot$dya.cat <<- def.code.cat(data = "datos", variable = paste0("'", input$sel.distribucion.cat, "'"))
  })

  # Pagina de Correlacion ---------------------------------------------------------------------------------------------------

  # Hace el grafico de correlacion
  observeEvent(c(input$loadButton, input$transButton, input$fieldModelCor), {
    output$plot.cor <- renderPlot({
      tryCatch({
        cod.cor <<- updatePlot$cor
        res <- isolate(eval(parse(text = cod.cor)))
        updateAceEditor(session, "fieldCodeCor", value = cod.cor)
        insert.report("correlacion", paste0("## Correlación \n```{r}\n", cod.cor, "\n```"))
        return(res)
      }, error = function(e) {
        if (ncol(var.numericas(datos)) == 0){
          error.plot.tipos.variables(T)
        }else{
          showNotification(paste0("ERROR EN Correlacion: ", e),
                           duration = 10,
                           type = "error")
          return(NULL)
        }
      })
    })
  })

  # Ejecuta el codigo del grafico
  observeEvent(input$run.code.cor, {
    updatePlot$cor <- input$fieldCodeCor
  })

  # Ejecuta el codigo cuando cambian los parametros
  observeEvent(c(input$cor.metodo, input$cor.tipo), {
    updatePlot$cor <- correlaciones(metodo = input$cor.metodo, tipo = input$cor.tipo)
  })

  # Pagina de Poder Predictivo ----------------------------------------------------------------------------------------------

  # Hace el grafico de poder predictivo distribucion de la variable predictora
  observeEvent(input$segmentButton, {
    output$plot.pred.poder <- renderPlot({
      tryCatch({
        cod.poder <<- updatePlot$poder.pred
        res <- isolate(eval(parse(text = cod.poder)))
        updateAceEditor(session, "fieldCodePoderPred", value = cod.poder)
        insert.report("poder.pred", paste0("## Distribución Variable Discriminante \n```{r}\n", cod.poder, "\n```"))
        return(res)
      }, error = function(e) {
        showNotification(paste0("Error en Poder Predictivo: ", e),
                         duration = 10,
                         type = "error")
        return(NULL)
      })
    })
  })

  # Ejecuta el codigo del grafico
  observeEvent(input$run.code.poder.pred, {
    updatePlot$poder.pred <- input$fieldCodePoderPred
  })

  # Hace el grafico de poder predictivo categorico
  observeEvent(input$segmentButton, {
    output$plot.dist.poder <- renderPlot({
      tryCatch({
        cod.poder.cat <<- updatePlot$poder.cat
        updateAceEditor(session, "fieldCodePoderCat", value = cod.poder.cat)
        if (ncol(var.categoricas(datos)) > 1) {
          res <- isolate(eval(parse(text = cod.poder.cat)))
          insert.report(paste0("poder.cat.",input$sel.distribucion.poder),
                        paste0("## Distribución Según Variable Discriminante \n```{r}\n", cod.poder.cat, "\n```"))
        }else{
          error.plot.tipos.variables(num = F)
        }
        return(res)
      }, error = function(e) {
        showNotification(paste0("Error en Poder Predictivo: ", e), duration = 10,type = "error")
        return(NULL)
      })
    })
  })

  # Ejecuta el codigo del grafico
  observeEvent(input$run.code.poder.cat, {
    updatePlot$poder.cat <- input$fieldCodePoderCat
  })

  # Ejecuta el codigo cuando cambian los parametros
  observeEvent(input$sel.distribucion.poder, {
    if (input$sel.distribucion.poder != "") {
      updatePlot$poder.cat <- plot.code.dist.porc(
        input$sel.distribucion.poder,
        input$sel.distribucion.poder,
        variable.predecir, variable.predecir
      )
    } else {
      updatePlot$poder.cat <- ""
    }
  })

  # Hace el grafico de poder predictivo numerico
  observeEvent(input$segmentButton,{
    output$plot.pairs.poder <- renderPlot({
      tryCatch({
        cod.poder.num <<- updatePlot$poder.num
        updateAceEditor(session, "fieldCodePoderNum", value = cod.poder.num)
        if (ncol(var.numericas(datos)) >= 2) {
          res <- isolate(eval(parse(text = cod.poder.num)))
          insert.report("poder.num",paste0("## Poder Predictivo Variables Numéricas \n```{r}\n", cod.poder.num, "\n```"))
          return(res)
        }else{
          error.plot.tipos.variables(num = T)
        }
      }, error = function(e) {
        showNotification(paste0("Error en Poder Predictivo: ", e),
                         duration = 10,
                         type = "error")
        return(NULL)
      })
    })
  })

  # Ejecuta el codigo del grafico
  observeEvent(input$run.code.poder.num, {
    if(input$fieldCodePoderNum != "") {
      updatePlot$poder.num <- input$fieldCodePoderNum
    } else {
      updatePlot$poder.num <- pairs.poder()
    }
  })

  observeEvent(input$segmentButton,{
    updatePlot$poder.num <- pairs.poder()
  }, priority = 3)

  # Hace el grafico de poder predictivo densidad de variables numericas
  observeEvent(input$segmentButton, {
    output$plot.density.poder <- renderPlot({
      tryCatch({
        cod.poder.den <<- updatePlot$poder.dens
        updateAceEditor(session, "fieldCodePoderDens", value = cod.poder.den)
        if (ncol(var.numericas(datos)) >= 1) {
          res <- isolate(eval(parse(text = cod.poder.den)))
          insert.report(paste0("poder.den.",input$sel.density.poder),
                        paste0("## Densidad Según Variable Discriminante\n```{r}\n", cod.poder.den, "\n```"))
        }else{
          error.plot.tipos.variables(num = T)
        }
        return(res)
      }, error = function(e) {
        showNotification(paste0("Error en Poder Predictivo: ", e),
                         duration = 10,
                         type = "error")
        return(NULL)
      })
    })
  })

  # Ejecuta el codigo del grafico
  observeEvent(input$run.code.poder.dens,{
    updatePlot$poder.dens <- input$fieldCodePoderDens
  })

  # Ejecuta el codigo cuando cambian los parametros
  observeEvent(input$sel.density.poder, {
    if (input$sel.density.poder != "") {
      updatePlot$poder.dens <- plot.numerico.dens( input$sel.density.poder)
    } else {
      updatePlot$poder.dens <- ""
    }
  })

  # Pagina de KNN -----------------------------------------------------------------------------------------------------------

  # Cuando se genera el modelo knn
  observeEvent(input$runKnn, {
    if (validar.datos()) { # Si se tiene los datos entonces :

      cod.knn.modelo <<- input$fieldCodeKnn
      cod.knn.pred <<- input$fieldCodeKnnPred
      cod.knn.mc <<- input$fieldCodeKnnMC
      cod.knn.ind <<- input$fieldCodeKnnIG

      knn.full()
    }
  })

  # Si las opciones cambian
  observeEvent(c(input$switch.scale.knn, input$kmax.knn, input$kernel.knn), {
    if (validar.datos(print = FALSE) & knn.stop.excu) {
      default.codigo.knn()
      knn.full()
    }else{
      knn.stop.excu <<- TRUE
    }
  })

  # Acualiza el codigo a la version por defecto
  default.codigo.knn <- function(k.def = FALSE) {
    if(!is.null(datos.aprendizaje) & k.def){
      k.value <- ifelse(k.def, round(sqrt(nrow(datos.aprendizaje))), input$kmax.knn)
      updateNumericInput(session,"kmax.knn",value = k.value)
    }else{
      k.value <- input$kmax.knn
    }

    # Se acualiza el codigo del modelo
    codigo <- kkn.modelo(
      variable.pr = variable.predecir,
      scale = input$switch.scale.knn,
      kmax = k.value,
      kernel = input$kernel.knn
    )
    updateAceEditor(session, "fieldCodeKnn", value = codigo)
    cod.knn.modelo <<- codigo

    # Se genera el codigo de la prediccion
    codigo <- kkn.prediccion(kernel = input$kernel.knn)
    updateAceEditor(session, "fieldCodeKnnPred", value = codigo)
    cod.knn.pred <<- codigo

    # Se genera el codigo de la matriz
    codigo <- knn.MC(variable.predecir, kernel = input$kernel.knn)
    updateAceEditor(session, "fieldCodeKnnMC", value = codigo)
    cod.knn.mc <<- codigo

    # Se genera el codigo de la indices
    codigo <- cod.indices()
    updateAceEditor(session, "fieldCodeKnnIG", value = codigo)
    cod.knn.ind <<- codigo
  }

  # Limpia los datos segun el proceso donde se genera el error
  limpia.knn <- function(capa = NULL) {
    for (i in capa:4) {
      switch(i, {
        exe("modelo.knn.",input$kernel.knn," <<- NULL")
        output$txtknn <- renderPrint(invisible(""))
        insert.report(paste0("modelo.knn.",input$kernel.knn), NULL)
      }, {
        exe("prediccion.knn.",input$kernel.knn," <<- NULL")
        insert.report(paste0("pred.knn.",input$kernel.knn), NULL)
        output$knnPrediTable <- DT::renderDataTable(NULL)
      }, {
        exe("MC.knn.",input$kernel.knn," <<- NULL")
        insert.report(paste0("mc.knn.",input$kernel.knn), NULL)
        output$plot.knn.mc <- renderPlot(NULL)
        output$txtknnMC <- renderPrint(invisible(NULL))
        MCs[[paste0("KNN - ",input$kernel.knn)]] <<- NULL
      }, {
        exe("indices.knn.",input$kernel.knn," <<- NULL")
        insert.report(paste0("ind.knn.",input$kernel.knn), NULL)
      })
    }
  }

  # Ejecuta el modelo, prediccion, mc e indices de knn
  knn.full <- function() {
    ejecutar.knn()
    ejecutar.knn.pred()
    ejecutar.knn.mc()
    ejecutar.knn.ind()
  }

  # Genera el modelo
  ejecutar.knn <- function() {
    tryCatch({

      eval(parse(text = cod.knn.modelo))
      updateAceEditor(session, "fieldCodeKnn", value = cod.knn.modelo)
      output$txtknn <- renderPrint(exe("modelo.knn.",input$kernel.knn))
      insert.report(paste0("modelo.knn.",input$kernel.knn),
                    paste0("## Generación del modelo KNN - ",input$kernel.knn,"\n```{r}\n",cod.knn.modelo, "\nmodelo.knn.",input$kernel.knn,"\n```"))
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.knn(1)
      showNotification(paste0("Error al ejecutar el modelo knn : ", e), duration = 15, type = "error")
    }
    )
  }

  # Genera la prediccion
  ejecutar.knn.pred <- function() {
    tryCatch({ # Se corren los codigo
      eval(parse(text = cod.knn.pred))
      scores[[paste0("KNN - ",input$kernel.knn)]] <<- predict(exe("modelo.knn.",input$kernel.knn), datos.prueba, type = "prob")

      # Cambia la tabla con la prediccion de knn
      output$knnPrediTable <- DT::renderDataTable(obj.predic(exe("prediccion.knn.",input$kernel.knn)),server = FALSE)
      insert.report(paste0("pred.knn.",input$kernel.knn),
                    paste0("## Predicción del Modelo KNN - ",input$kernel.knn,"\n```{r}\n", cod.knn.pred,
                           "\nhead(dt.to.data.frame.predict(obj.predic(prediccion.knn.",input$kernel.knn,")))\n",
                           "scores[['",paste0("KNN - ",input$kernel.knn),"']] <<- predict(modelo.knn.",input$kernel.knn,",datos.prueba, type = 'prob')\n```"))

      updatePlot$roc <- !updatePlot$roc #graficar otra vez la curva roc
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.knn(2)
      showNotification(paste0("Error al ejecutar la prediccion knn : ", e), duration = 15, type = "error")
    }
    )
  }

  # Genera la matriz de confusion
  ejecutar.knn.mc <- function() {
    tryCatch({ # Se corren los codigo
      eval(parse(text = cod.knn.mc))
      output$txtknnMC <- renderPrint(print(exe("MC.knn.",input$kernel.knn)))

      eval(parse(text = plot.MC.code()))
      output$plot.knn.mc <- renderPlot(exe("plot.MC(MC.knn.",input$kernel.knn,")"))
      insert.report(paste0("mc.knn.",input$kernel.knn),
                    paste0("## Matriz de confusión del Modelo KNN - ",
                           input$kernel.knn,"\n```{r}\n", cod.knn.mc,
                           "\nMC.knn.",input$kernel.knn,
                           "\n```\n```{r}\nplot.MC(MC.knn.",input$kernel.knn,")\n",
                           "MCs[['KNN - ",input$kernel.knn,"']] <<- MC.knn.",input$kernel.knn,"\n```"))
      MCs[[paste0("KNN - ",input$kernel.knn)]] <<- exe("MC.knn.",input$kernel.knn)
      actualizar.selector.comparativa()
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.knn(3)
      showNotification(paste0("Error al ejecutar la matriz knn: ",e), duration = 15, type = "error")
    }
    )
  }

  # Genera los indices
  ejecutar.knn.ind <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.knn.ind)))

      MC <- exe("MC.knn.",input$kernel.knn)
      indices.knn <- indices.generales(MC)
      eval(parse(text = paste0("indices.knn.",input$kernel.knn, "<<- indices.knn")))
      indices.g("knn", MC)

      insert.report(paste0("ind.knn.",input$kernel.knn),
                    paste0("## Índices Generales del Modelo KNN - ",input$kernel.knn,"\n```{r}\n",
                           cod.knn.ind, "\nindices.generales(MC.knn.",input$kernel.knn,")\n```"))

      nombres <- c("knnPrecGlob", "knnErrorGlob")
      titulos <- c("Precisión Global", "Error Global")

      fill.gauges(nombres, titulos, indices.knn)

      # Cambia la tabla con la indices de knn
      output$knnIndPrecTable <- shiny::renderTable(xtable(indices.prec.table(indices.knn,"KNN")),
                                                   bordered = T, width = "100%", align = "c", digits = 2)

      output$knnIndErrTable <- shiny::renderTable(xtable(indices.error.table(indices.knn,"KNN")),
                                                  bordered = T, width = "100%", align = "c", digits = 2)

    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.knn(4)
      showNotification(paste0("Error al ejecutar los indices: ",e), duration = 15, type = "error")
    }
    )
  }

  # PAGINA DE SVM -----------------------------------------------------------------------------------------------------------

  # Cuando se genera el modelo svm
  observeEvent(input$runSvm, {
    if (validar.datos()) { # Si se tiene los datos entonces :
      cod.svm.modelo <<- input$fieldCodeSvm
      cod.svm.pred <<- input$fieldCodeSvmPred
      cod.svm.mc <<- input$fieldCodeSvmMC
      cod.svm.ind <<- input$fieldCodeSvmIG

      svm.full()
    }
  })

  # Si las opciones cambian
  observeEvent(c(input$switch.scale.svm, input$kernel.svm), {
    if (validar.datos(print = FALSE)) {
      default.codigo.svm()
      svm.full()
    }
  })

  # Acualiza el codigo a la version por defecto
  default.codigo.svm <- function() {
    # Se acualiza el codigo del modelo
    codigo <- svm.modelo(
      variable.pr = variable.predecir,
      scale = input$switch.scale.svm,
      kernel = input$kernel.svm)

    updateAceEditor(session, "fieldCodeSvm", value = codigo)
    cod.svm.modelo <<- codigo

    # Acutaliza el codigo del grafico de clasificacion svm
    updateAceEditor(session, "fieldCodeSvmPlot", value = "")

    # Se genera el codigo de la prediccion
    codigo <- svm.prediccion(input$kernel.svm)
    updateAceEditor(session, "fieldCodeSvmPred", value = codigo)
    cod.svm.pred <<- codigo

    # Se genera el codigo de la matriz
    codigo <- svm.MC(variable.predecir,input$kernel.svm)
    updateAceEditor(session, "fieldCodeSvmMC", value = codigo)
    cod.svm.mc <<- codigo

    # Se genera el codigo de la indices
    codigo <- cod.indices()
    updateAceEditor(session, "fieldCodeSvmIG", value = codigo)
    cod.svm.ind <<- codigo
  }

  # Limpia los datos segun el proceso donde se genera el error
  limpia.svm <- function(capa = NULL) {
    for (i in capa:4) {
      switch(i, {
        exe("modelo.svm.",input$kernel.svm,"<<- NULL")
        output$txtSvm <- renderPrint(invisible(""))
        insert.report(paste0("modelo.svm.",input$kernel.svm), NULL)
        insert.report(grepl(paste0("svm.plot.",input$kernel.svm), names.report()), NULL)
      }, {
        exe("prediccion.svm.",input$kernel.svm,"<<- NULL")
        insert.report(paste0("pred.svm.",input$kernel.svm), NULL)
        output$svmPrediTable <- DT::renderDataTable(NULL)
      }, {
        exe("MC.svm.",input$kernel.svm,"<<- NULL")
        insert.report(paste0("mc.svm.",input$kernel.svm), NULL)
        output$txtSvmMC <- renderPrint(invisible(""))
        output$plot.svm.mc <- renderPlot(NULL)
        MCs[[paste0("SVM -",input$kernel.svm)]] <<- NULL
      }, {
        exe("indices.svm.",input$kernel.svm,"<<- NULL")
        insert.report(paste0("ind.svm.",input$kernel.svm), NULL)
      })
    }
  }

  # Ejecuta el modelo, prediccion, mc e indices de svm
  svm.full <- function() {
    ejecutar.svm()
    ejecutar.svm.pred()
    ejecutar.svm.mc()
    ejecutar.svm.ind()
  }

  # Genera el modelo
  ejecutar.svm <- function() {
    tryCatch({ # Se corren los codigo

      isolate(eval(parse(text = cod.svm.modelo)))
      output$txtSvm <- renderPrint(exe("print(modelo.svm.",input$kernel.svm,")"))
      updateAceEditor(session, "fieldCodeSvm", value = cod.svm.modelo)
      insert.report(paste0("modelo.svm.",input$kernel.svm),
                    paste0("## Generación del modelo SVM - ",input$kernel.svm,"\n```{r}\n",
                           cod.svm.modelo, "\nmodelo.svm.",input$kernel.svm,"\n```"))
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.svm(1)
      showNotification(paste0("Error al ejecutar el modelo svm:",e), duration = 15, type = "error")
    }
    )
  }

  # Genera la prediccion
  ejecutar.svm.pred <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.svm.pred)))

      modelo.svm.roc <- svm(as.formula(paste0(variable.predecir, "~.")),
                            data = datos.aprendizaje,
                            scale = T,
                            kernel = input$kernel.svm,
                            probability = T)

      scores[[paste0("SVM -",input$kernel.svm)]] <<- predict(modelo.svm.roc, datos.prueba, probability = T)

      # Cambia la tabla con la prediccion de knn
      output$svmPrediTable <- DT::renderDataTable(exe("obj.predic(prediccion.svm.",input$kernel.svm,")"),server = FALSE)
      insert.report(paste0("pred.svm.",input$kernel.svm),
                    paste0("## Predicción del Modelo SVM - ",input$kernel.svm,"\n```{r}\n", cod.svm.pred,
                           "\nhead(dt.to.data.frame.predict(obj.predic(prediccion.svm.",input$kernel.svm,")))\n",
                           "modelo.svm.roc <- svm(as.formula(paste0(variable.predecir, '~.')),data = datos.aprendizaje,scale = T,kernel = '",
                           input$kernel.svm,"',probability = T)\n",
                           "scores[['SVM -",input$kernel.svm,"']] <<- predict(modelo.svm.roc,datos.prueba, probability = T)\n```"))

      updatePlot$roc <- !updatePlot$roc #graficar otra vez la curva roc
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.svm(2)
      showNotification(paste0("Error al ejecutar la prediccion svm:",e), duration = 15, type = "error")
    }
    )
  }

  # Genera la matriz de confusion
  ejecutar.svm.mc <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.svm.mc)))
      output$txtSvmMC <- renderPrint(exe("print(MC.svm.",input$kernel.svm,")"))
      isolate(eval(parse(text = plot.MC.code())))
      output$plot.svm.mc <- renderPlot(exe("plot.MC(MC.svm.",input$kernel.svm,")"))
      insert.report(paste0("mc.svm.",input$kernel.svm),
                    paste0("## Matriz de Confusión del Modelo SVM - ",input$kernel.svm,"\n```{r}\n",
                           cod.svm.mc, "\nMC.svm.",input$kernel.svm,"\n```\n```{r}\nplot.MC(MC.svm.",input$kernel.svm,")\n",
                           "MCs[['SVM -",input$kernel.svm,"']] <<- MC.svm.",input$kernel.svm,"\n```"))

      MCs[[paste0("SVM -",input$kernel.svm)]] <<- exe("MC.svm.",input$kernel.svm)
      actualizar.selector.comparativa()
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.svm(3)
      showNotification(paste0("Error al ejecutar la matriz svm:",e), duration = 15, type = "error")
    }
    )
  }

  # Genera los indices
  ejecutar.svm.ind <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.svm.ind)))

      MC <- exe("MC.svm.",input$kernel.svm)
      indices.svm <- indices.generales(MC)
      eval(parse(text = paste0("indices.svm.",input$kernel.svm, "<<- indices.svm")))
      indices.g("svm", MC)

      insert.report(paste0("ind.svm.",input$kernel.svm),
                    paste0("## Índices Generales del modelo SVM  - ",input$kernel.svm," \n```{r}\n",
                           cod.svm.ind, "\nindices.generales(MC.svm.",input$kernel.svm,")\n```"))

      nombres <- c("svmPrecGlob", "svmErrorGlob")
      titulos <- c("Precisión Global", "Error Global")

      fill.gauges(nombres, titulos, indices.svm)

      # Cambia la tabla con la indices de svm
      output$svmIndPrecTable <- shiny::renderTable(xtable(indices.prec.table(indices.svm,"SVM")),
                                                   bordered = T, width = "100%", align = "c", digits = 2)

      output$svmIndErrTable <- shiny::renderTable(xtable(indices.error.table(indices.svm,"SVM")),
                                                  bordered = T, width = "100%", align = "c", digits = 2)
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.knn(4)
      showNotification(paste0("Error al ejecutar los indices svm: ",e), duration = 15, type = "error")
    }
    )
  }

  #Hace el grafico de svm
  output$plot.svm <- renderPlot({
    tryCatch({
      codigo <- updatePlot$svm.graf
      if(!is.null(codigo) & codigo != ""){
        insert.report(paste0("svm.plot.",input$kernel.svm,paste0(input$select.var.svm.plot, collapse = ".")),
                      paste0("\n```{r}\n",codigo, "\n```"))
        exe(codigo)
      }else{
        if (!(ncol(var.numericas(datos)) >= 2)) {
          error.plot.tipos.variables(num = T)
        }
        return(NULL)
      }},error=function(e){
        return(NULL)
    })
  })

  # Cuando cambia el codigo del grafico de clasificacion svm
  observeEvent(c(input$runSvm, input$select.var.svm.plot),{
    if (length(input$select.var.svm.plot) == 2) {
      v <- colnames(datos)
      v <- v[v != variable.predecir]
      v <- v[!(v %in% input$select.var.svm.plot)]
      if (length(v) == 0) {
        v <- input$select.var.svm.plot
      }
      updateAceEditor(session, "fieldCodeSvmPlot", value = svm.plot(input$select.var.svm.plot, v, input$kernel.svm))
    } else {
      updatePlot$svm.graf <- NULL
    }
  })

  observeEvent(c(input$fieldCodeSvmPlot),{
     updatePlot$svm.graf <- input$fieldCodeSvmPlot
  })

  # PAGINA DE DT ------------------------------------------------------------------------------------------------------------

  # Cuando se genera el modelo dt
  observeEvent(input$runDt, {
    if (validar.datos()) { # Si se tiene los datos entonces :
      cod.dt.modelo <<- input$fieldCodeDt
      cod.dt.pred <<- input$fieldCodeDtPred
      cod.dt.mc <<- input$fieldCodeDtMC
      cod.dt.ind <<- input$fieldCodeDtIG

      dt.full()
    }
  })

  # Si las opciones cambian
  observeEvent(c(input$minsplit.dt, input$maxdepth.dt, input$split.dt), {
    if (validar.datos(print = FALSE)) {
      default.codigo.dt()
      dt.full()
    }
  })

  # Acualiza el codigo a la version por defecto
  default.codigo.dt <- function() {

    # Se acualiza el codigo del modelo
    codigo <- dt.modelo(variable.pr = variable.predecir,
                        minsplit = input$minsplit.dt,
                        maxdepth = input$maxdepth.dt,
                        split = input$split.dt)

    updateAceEditor(session, "fieldCodeDt", value = codigo)
    cod.dt.modelo <<- codigo

    # Cambia el codigo del grafico del árbol
    updateAceEditor(session, "fieldCodeDtPlot", value = dt.plot())

    # Se genera el codigo de la prediccion
    codigo <- dt.prediccion()
    updateAceEditor(session, "fieldCodeDtPred", value = codigo)
    cod.dt.pred <<- codigo

    # Se genera el codigo de la matriz
    codigo <- dt.MC(variable.predecir)
    updateAceEditor(session, "fieldCodeDtMC", value = codigo)
    cod.dt.mc <<- codigo

    # Se genera el codigo de la indices
    codigo <- cod.indices()
    updateAceEditor(session, "fieldCodeDtIG", value = codigo)
    cod.dt.ind <<- codigo
  }

  #Plotear el arbol
  plotear.arbol <- function(){
    tryCatch({
      output$plot.dt <- renderPlot(isolate(eval(parse(text = input$fieldCodeDtPlot))))
      cod <- ifelse(input$fieldCodeDtPlot == "", dt.plot(), input$fieldCodeDtPlot)
      insert.report(paste0("modelo.dt.graf.", input$split.dt), paste0("\n```{r}\n", cod, "\n```"))
    },
    error = function(e){
      output$plot.dt <- renderPlot(NULL)
      insert.report(paste0("modelo.dt.graf.",input$split.dt),NULL)
    })
  }

  #Mostrar Reglas
  mostrar.reglas.dt <- function(){
    output$rulesDt <- renderPrint(rattle::asRules(exe("modelo.dt.",input$split.dt)))
    insert.report(paste0("modelo.dt.rules.",input$split.dt),
                  paste0("\n```{r}\nrattle::asRules(modelo.dt.",input$split.dt,")\n```"))
  }

  # Limpia los datos segun el proceso donde se genera el error
  limpia.dt <- function(capa = NULL) {
    for (i in capa:4) {
      switch(i, {
        modelo.dt <<- NULL
        output$txtDt <- renderPrint(invisible(""))
        output$plot.dt <- renderPlot(NULL)
        insert.report(paste0("modelo.dt.", input$split.dt), NULL)
        insert.report(paste0("modelo.dt.graf.", input$split.dt), NULL)
      }, {
        prediccion.dt <<- NULL
        insert.report(paste0("pred.dt.", input$split.dt), NULL)
        output$dtPrediTable <- DT::renderDataTable(NULL)
      }, {
        MC.dt <<- NULL
        insert.report(paste0("mc.dt.", input$split.dt), NULL)
        output$plot.dt.mc <- renderPlot(NULL)
        output$txtDtMC <- renderPrint(invisible(NULL))
        MCs[[paste0("Árboles de Decisión - ", input$split.dt)]] <<- NULL
      }, {
        indices.dt <<- rep(0, 10)
        insert.report(paste0("ind.dt.",input$split.dt), NULL)
      })
    }
  }

  # Ejecuta el modelo, prediccion, mc e indices de dt
  dt.full <- function() {
    ejecutar.dt()
    ejecutar.dt.pred()
    ejecutar.dt.mc()
    ejecutar.dt.ind()
  }

  # Genera el modelo
  ejecutar.dt <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.dt.modelo)))
      output$txtDt <- renderPrint(print(exe("modelo.dt.", input$split.dt)))
      insert.report(paste0("modelo.dt.", input$split.dt),
                    paste0("## Generación del modelo Árboles de Decisión\n```{r}\n", cod.dt.modelo,
                           "\nmodelo.dt.",input$split.dt,"\n```"))
      plotear.arbol()
      mostrar.reglas.dt()
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.dt(1)
      showNotification(paste0("Error al ejecutar el modelo dt:",e), duration = 15, type = "error")
    }
    )
  }

  # Genera la prediccion
  ejecutar.dt.pred <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.dt.pred)))
      scores[[paste0("Árboles de Decisión - ", input$split.dt)]] <<- exe("predict(modelo.dt.",input$split.dt,", datos.prueba, type = 'prob')")
      # Cambia la tabla con la prediccion de dt
      output$dtPrediTable <- DT::renderDataTable(obj.predic(exe("prediccion.dt.",input$split.dt)),server = FALSE)
      insert.report(paste0("pred.dt.", input$split.dt),
                    paste0("## Predicción del Modelo Árboles de Decisión\n```{r}\n", cod.dt.pred,
                           "\nhead(dt.to.data.frame.predict(obj.predic(prediccion.dt.",input$split.dt,")))\n",
                           "scores[['Árboles de Decisión - ",input$split.dt,"']] <<- predict(modelo.dt.",input$split.dt,", datos.prueba, type = 'prob')\n```"))

      updatePlot$roc <- !updatePlot$roc #graficar otra vez la curva roc
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.dt(2)
      showNotification(paste0("Error al ejecutar la prediccion dt: ",e), duration = 15, type = "error")
    }
    )
  }

  # Genera la matriz de confusion
  ejecutar.dt.mc <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.dt.mc)))
      output$txtDtMC <- renderPrint(print(exe("MC.dt.",input$split.dt)))
      isolate(eval(parse(text = plot.MC.code())))
      output$plot.dt.mc <- renderPlot(isolate(exe("plot.MC(MC.dt.",input$split.dt,")")))
      insert.report(paste0("mc.dt.",input$split.dt),
                    paste0("## Matriz de Confusión del Modelo Árboles de Decisión\n```{r}\n", cod.dt.mc,
                           "\nMC.dt.",input$split.dt,"\n```\n```{r}\nplot.MC(MC.dt.",input$split.dt,")\n",
                           "MCs[['Árboles de Decisión - ",input$split.dt,"']] <<- MC.dt.",input$split.dt,"\n```"))

      MCs[[paste0("Árboles de Decisión - ",input$split.dt)]] <<- exe("MC.dt.",input$split.dt)
      actualizar.selector.comparativa()
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.dt(3)
      showNotification(paste0("Error al ejecutar la matriz dt :", e), duration = 15, type = "error")
    }
    )
  }

  # Genera los indices
  ejecutar.dt.ind <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.dt.ind)))
      indices.dt <<- indices.generales(exe("MC.dt.",input$split.dt))
      indices.g("dt", exe("MC.dt.",input$split.dt))

      insert.report(paste0("ind.dt.",input$split.dt), paste0("## Índices Generales \n```{r}\n", cod.dt.ind, "\nindices.generales(MC.dt.",input$split.dt,")\n```"))

      nombres <- c("dtPrecGlob", "dtErrorGlob")
      titulos <- c("Precisión Global", "Error Global")

      fill.gauges(nombres, titulos, indices.dt)

      # Cambia la tabla con la indices de dt
      output$dtIndPrecTable <- shiny::renderTable(xtable(indices.prec.table(indices.dt,"Árboles de Decisión")),
                                                  bordered = T, width = "100%", align = "c", digits = 2)

      output$dtIndErrTable <- shiny::renderTable(xtable(indices.error.table(indices.dt,"Árboles de Decisión")),
                                                 bordered = T, width = "100%", align = "c", digits = 2)
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.dt(4)
      showNotification(paste0("Error al ejecutar los indices dt :",e), duration = 15, type = "error")
    }
    )
  }

  # PAGINA DE RF ------------------------------------------------------------------------------------------------------------

  # Cuando se genera el modelo rf
  observeEvent(input$runRf, {
    if (validar.datos()) { # Si se tiene los datos entonces :
      cod.rf.modelo <<- input$fieldCodeRf
      cod.rf.pred <<- input$fieldCodeRfPred
      cod.rf.mc <<- input$fieldCodeRfMC
      cod.rf.ind <<- input$fieldCodeRfIG

      rf.full()
    }
  })

  # Si las opciones cambian
  observeEvent(c(input$ntree.rf,input$mtry.rf), {
    if (validar.datos(print = FALSE) & rf.stop.excu) {
      deafult.codigo.rf()
      rf.full()
    }else{
      rf.stop.excu <<- TRUE
    }
  })

  observeEvent(input$rules.rf.n,{
    if(validar.datos(print = FALSE)){
        mostrar.reglas.rf(input$rules.rf.n)
    }
  })

  # Acualiza el codigo a la version por defecto
  deafult.codigo.rf <- function(rf.def = FALSE) {

    if(!is.null(datos.aprendizaje) & rf.def){
      mtry.value <- ifelse(rf.def, round(sqrt(ncol(datos.aprendizaje))), input$mtry.rf)
      updateNumericInput(session,"mtry.rf",value = mtry.value)
    }else{
      mtry.value <- input$mtry.rf
    }

    # Se acualiza el codigo del modelo
    codigo <- rf.modelo(
      variable.pr = variable.predecir,
      ntree = input$ntree.rf,
      mtry = mtry.value)


    updateAceEditor(session, "fieldCodeRf", value = codigo)
    cod.rf.modelo <<- codigo

    updateAceEditor(session, "fieldCodeRfPlotError", value = plot.rf.error())

    # Se genera el codigo de la prediccion
    codigo <- rf.prediccion(variable.predecir)
    updateAceEditor(session, "fieldCodeRfPred", value = codigo)
    cod.rf.pred <<- codigo

    # Cambia el codigo del grafico de rf
    updateAceEditor(session, "fieldCodeRfPlot", value = rf.plot())

    # Se genera el codigo de la matriz
    codigo <- rf.MC(variable.predecir)
    updateAceEditor(session, "fieldCodeRfMC", value = codigo)
    cod.rf.mc <<- codigo

    # Se genera el codigo de la indices
    codigo <- cod.indices()
    updateAceEditor(session, "fieldCodeRfIG", value = codigo)
    cod.rf.ind <<- codigo
  }

  # Limpia los datos segun el proceso donde se genera el error
  limpia.rf <- function(capa = NULL) {
    for (i in capa:4) {
      switch(i, {
        modelo.rf <<- NULL
        output$txtRf <- renderPrint(invisible(""))
        insert.report("modelo.rf",NULL)
        insert.report("modelo.rf.graf",NULL)
      }, {
        prediccion.rf <<- NULL
        insert.report("pred.rf",NULL)
        output$rfPrediTable <- DT::renderDataTable(NULL)
      }, {
        MC.rf <<- NULL
        insert.report("mc.rf",NULL)
        output$plot.rf.mc <- renderPlot(NULL)
        output$txtRfMC <- renderPrint(invisible(NULL))
        MCs[["Bosques Aleatorios"]] <<- NULL
      }, {
        indices.rf <<- rep(0, 10)
        insert.report("ind.rf",NULL)
      })
    }
  }

  # Grafico de importancia
  plotear.rf.imp <- function() {
    tryCatch({
      output$plot.rf <- renderPlot(isolate(eval(parse(text = input$fieldCodeRfPlot))))
      cod <- ifelse(input$fieldCodeRfPlot == "", rf.plot(), input$fieldCodeRfPlot)
      insert.report("modelo.rf.graf", paste0("## Importancia de las Variables\n```{r}\n", cod , "\n```"))
    }, error = function(e) {
      output$plot.rf <- renderPlot(NULL)
      insert.report("modelo.rf.graf",NULL)
    })
  }

  plotear.rf.error <- function(){
    tryCatch({
      output$plot.error.rf <- renderPlot(isolate(eval(parse(text = input$fieldCodeRfPlotError))))
      cod <- ifelse(input$fieldCodeRfPlotError == "", plot.rf.error(),input$fieldCodeRfPlotError)
      insert.report("modelo.rf.error.",
                    paste0("## Evolución del Error del Modelo Bosques Aleatorios\n```{r}\n", cod, "\n```"))
    }, error = function(e) {
      limpia.rf(1)
    })
  }

  #Mostrar Reglas
  mostrar.reglas.rf <- function(n){
    output$rulesRf <- renderPrint({
      tryCatch({printRandomForests(modelo.rf, n)},
                error = function(e) stop("No se puede mostrar las reglas para el árbol seleccionado"))})
    insert.report(paste0("modelo.rf.rules.", n), paste0("\n## Reglas del árbol #",n," \n```{r}\nprintRandomForests(modelo.rf, ",n,")\n```"))
  }

  # Ejecuta el modelo, prediccion, mc e indices de rf
  rf.full <- function() {
    ejecutar.rf()
    ejecutar.rf.pred()
    ejecutar.rf.mc()
    ejecutar.rf.ind()
  }

  # Genera el modelo
  ejecutar.rf <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.rf.modelo)))
      output$txtRf <- renderPrint(print(modelo.rf))
      insert.report("modelo.rf",paste0("## Generación del Modelo Bosques Aleatorios\n```{r}\n", cod.rf.modelo, "\nmodelo.rf\n```"))
      plotear.rf.imp()
      plotear.rf.error()
      mostrar.reglas.rf(input$rules.rf.n)
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.rf(1)
      showNotification(paste0("Error al ejecutar el modelo rf :",e), duration = 15, type = "error")
    }
    )
  }

  # Genera la prediccion
  ejecutar.rf.pred <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.rf.pred)))
      scores[["Bosques Aleatorios"]] <<- predict(modelo.rf, datos.prueba[, -which(colnames(datos.prueba) == variable.predecir)], type = "prob")
      # Cambia la tabla con la prediccion de rf
      output$rfPrediTable <- DT::renderDataTable(obj.predic(prediccion.rf),server = FALSE)
      insert.report("pred.rf",
                    paste0("## Predicción del Modelo Bosques Aleatorios\n```{r}\n", cod.rf.pred,
                           "\nhead(dt.to.data.frame.predict(obj.predic(prediccion.rf)))\n",
                           "scores[['Bosques Aleatorios']] <<- predict(modelo.rf, datos.prueba[, -which(colnames(datos.prueba) == variable.predecir)], type = 'prob')\n```"))
      updatePlot$roc <- !updatePlot$roc #graficar otra vez la curva roc
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.rf(2)
      showNotification(paste0("Error al ejecutar la prediccion rf :", e), duration = 15, type = "error")
    }
    )
  }

  # Genera la matriz de confusion
  ejecutar.rf.mc <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.rf.mc)))
      output$txtRfMC <- renderPrint(print(MC.rf))
      isolate(eval(parse(text = plot.MC.code())))
      output$plot.rf.mc <- renderPlot(isolate(eval(parse(text = "plot.MC(MC.rf)"))))
      insert.report("mc.rf",paste0("## Matriz de Confusión del Modelo Bosques Aleatorios\n```{r}\n", cod.rf.mc,
                                   "\nMC.rf\n```\n```{r}\nplot.MC(MC.rf)\n",
                                   "MCs[['Bosques Aleatorios']] <<- MC.rf\n```"))

      MCs[["Bosques Aleatorios"]] <<- MC.rf
      actualizar.selector.comparativa()
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.rf(3)
      showNotification(paste0("Error al ejecutar la matriz rf:",e), duration = 15, type = "error")
    }
    )
  }

  # Genera los indices
  ejecutar.rf.ind <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.rf.ind)))
      indices.rf <<- indices.generales(MC.rf)
      indices.g("rf", MC.rf)

      insert.report("ind.rf",paste0("## Índices Generales\n```{r}\n", cod.rf.ind, "\nindices.generales(MC.rf)\n```"))

      nombres <- c("rfPrecGlob", "rfErrorGlob")
      titulos <- c("Precisión Global", "Error Global")

      fill.gauges(nombres, titulos, indices.rf)

      # Cambia la tabla con la indices de rf
      output$rfIndPrecTable <- shiny::renderTable(xtable(indices.prec.table(indices.rf,"Bosques Aleatorios")),
                                                  bordered = T, width = "100%", align = "c", digits = 2)

      output$rfIndErrTable <- shiny::renderTable(xtable(indices.error.table(indices.rf,"Bosques Aleatorios")),
                                                 bordered = T, width = "100%", align = "c", digits = 2)

    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.rf(4)
      showNotification(paste0("Error al ejecutar los indices rf :",e), duration = 15, type = "error")
    }
    )
  }

  # PAGINA DE BOOSTING ------------------------------------------------------------------------------------------------------

  # Cuando se genera el modelo boosting
  observeEvent(input$runBoosting, {
    if (length(levels(datos[, variable.predecir])) == 2) {
      if (validar.datos()) { # Si se tiene los datos entonces :
        cod.b.modelo <<- input$fieldCodeBoosting
        cod.b.pred <<- input$fieldCodeBoostingPred
        cod.b.mc <<- input$fieldCodeBoostingMC
        cod.b.ind <<- input$fieldCodeBoostingIG

        boosting.full()
      }
    } else {
      showModal(modalDialog(
        title = "ADA - BOOSTING", "Este modelo solo se puede aplicar a variables binarias",
        footer = modalButton("Cerrar"), easyClose = T
      ))
    }
  })

  observeEvent(input$rules.b.n,{
    if(validar.datos(print = FALSE)){
      mostrar.reglas.boosting(input$rules.b.n)
    }
  })

  # Si las opciones cambian o actualizar el codigo
  observeEvent(c(input$iter.boosting, input$nu.boosting, input$tipo.boosting, input$minsplit.boosting, input$maxdepth.boosting), {
    if (validar.datos(print = FALSE) & length(levels(datos[, variable.predecir])) == 2) {
      deault.codigo.boosting()
      boosting.full()
    }
  })

  # Acualiza el codigo a la version por defecto
  deault.codigo.boosting <- function() {
    # Se acualiza el codigo del modelo
    codigo <- boosting.modelo(
      variable.pr = variable.predecir,
      iter = input$iter.boosting,
      maxdepth = input$maxdepth.boosting,
      type = input$tipo.boosting,
      minsplit = input$minsplit.boosting)

    updateAceEditor(session, "fieldCodeBoosting", value = codigo)
    cod.b.modelo <<- codigo

    # Se genera el codigo de la prediccion
    codigo <- boosting.prediccion(variable.predecir, input$tipo.boosting)
    updateAceEditor(session, "fieldCodeBoostingPred", value = codigo)
    cod.b.pred <<- codigo

    # Cambia el codigo del grafico del modelo
    updateAceEditor(session, "fieldCodeBoostingPlot", value = boosting.plot(input$tipo.boosting))

    # Cambia el codigo del grafico de importancia
    updateAceEditor(session, "fieldCodeBoostingPlotImport", value = boosting.plot.import(input$tipo.boosting))

    # Se genera el codigo de la matriz
    codigo <- boosting.MC(variable.predecir, input$tipo.boosting)
    updateAceEditor(session, "fieldCodeBoostingMC", value = codigo)
    cod.b.mc <<- codigo

    # Se genera el codigo de la indices
    codigo <- cod.indices()
    updateAceEditor(session, "fieldCodeBoostingIG", value = codigo)
    cod.b.ind <<- codigo
  }

  # Limpia los datos segun el proceso donde se genera el error
  limpia.boosting <- function(capa = NULL) {
    for (i in capa:4) {
      switch(i, {
        exe("modelo.boosting.",input$tipo.boosting," <<- NULL")
        output$txtBoosting <- renderPrint(invisible(""))
        output$plot.boosting <- renderPlot(NULL)
        output$plot.boosting.import <- renderPlot(NULL)
        insert.report(paste0("modelo.b.",input$tipo.boosting),NULL)
        insert.report(paste0("modelo.b.error.",input$tipo.boosting),NULL)
        insert.report(paste0("modelo.b.imp.",input$tipo.boosting),NULL)
      }, {
        exe("prediccion.boosting.",input$tipo.boosting," <<- NULL")
        insert.report(paste0("pred.b.",input$tipo.boosting),NULL)
        output$boostingPrediTable <- DT::renderDataTable(NULL)
      }, {
        exe("MC.boosting.",input$tipo.boosting," <<- NULL")
        insert.report(paste0("mc.b.",input$tipo.boosting),NULL)
        output$plot.boosting.mc <- renderPlot(NULL)
        output$txtBoostingMC <- renderPrint(invisible(NULL))
        MCs[["ADA-BOOSTING"]] <<- NULL
      }, {
        exe("indices.boosting.",input$tipo.boosting," <<- NULL")
        insert.report(paste0("ind.b.",input$tipo.boosting),NULL)
      })
    }
  }

  # Ejecuta el modelo, prediccion, mc e indices de knn
  boosting.full <- function() {
    if (length(levels(datos[, variable.predecir])) == 2) {
      ejecutar.boosting()
      ejecutar.boosting.pred()
      ejecutar.boosting.mc()
      ejecutar.boosting.ind()
    }
  }

  # Grafico de boosting
  plotear.boosting <- function() {
    tryCatch({
      output$plot.boosting <- renderPlot(isolate(eval(parse(text = input$fieldCodeBoostingPlot))))
      cod <- ifelse(input$fieldCodeBoostingPlot == "",boosting.plot(),input$fieldCodeBoostingPlot)
      insert.report(paste0("modelo.b.error.",input$tipo.boosting),
                    paste0("## Evolución del Error - ",input$tipo.boosting,"\n```{r}\n", cod, "\n```"))
    }, error = function(e) {
      limpia.boosting(1)
    })
  }

  # Grafico de importancia
  plotear.boosting.imp <- function() {
    tryCatch({
      output$plot.boosting.import <- renderPlot(isolate(eval(parse(text = input$fieldCodeBoostingPlotImport))))
      cod <- ifelse(input$fieldCodeBoostingPlotImport == "",boosting.plot.import(),input$fieldCodeBoostingPlotImport)
      insert.report(paste0("modelo.b.imp.",input$tipo.boosting),paste0("## Importancia de las Variables - ",input$tipo.boosting,"\n```{r}\n", cod , "\n```"))
    }, error = function(e) {
      limpia.boosting(1)
    })
  }

  #Mostrar Reglas
  mostrar.reglas.boosting <- function(n){
    output$rulesB <- renderPrint({
      tryCatch({exe(rules.boosting(type = input$tipo.boosting, input$rules.b.n))},
               error = function(e)stop("No se puede mostrar las reglas para el árbol seleccionado"))})
    insert.report(paste0("modelo.b.rules.", n), paste0("\n## Reglas del árbol #",n," \n```{r}\n",
                                                       rules.boosting(type = input$tipo.boosting, input$rules.b.n),"\n```"))
  }

  # Genera el modelo
  ejecutar.boosting <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.b.modelo)))
      output$txtBoosting <- renderPrint(exe("print(modelo.boosting.",input$tipo.boosting,")"))
      plotear.boosting()
      plotear.boosting.imp()
      mostrar.reglas.boosting(input$rules.b.n)
      insert.report(paste0("modelo.b.",input$tipo.boosting),
                    paste0("## Generación del Modelo ADA-BOOSTING - ",input$tipo.boosting,"\n```{r}\n",
                           cod.b.modelo, "\nmodelo.boosting.",input$tipo.boosting,"\n```"))
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.boosting(1)
      showNotification(paste0("Error al ejecutar el modelo boosting :",e), duration = 15, type = "error")
    }
    )
  }

  # Genera la prediccion
  ejecutar.boosting.pred <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.b.pred)))
      scores[[paste0("ADA-BOOSTING - ",input$tipo.boosting)]] <<- predict(exe("modelo.boosting.",input$tipo.boosting), datos.prueba[, -which(colnames(datos.prueba) == variable.predecir)], type = "prob")

      # Cambia la tabla con la prediccion de boosting
      output$boostingPrediTable <- DT::renderDataTable(obj.predic(exe("prediccion.boosting.",input$tipo.boosting)),server = FALSE)
      insert.report(paste0("pred.b.",input$tipo.boosting),
                    paste0("## Predicción del Modelo ADA-BOOSTING - ",input$tipo.boosting,"\n```{r}\n",
                    cod.b.pred,"\nhead(dt.to.data.frame.predict(obj.predic(prediccion.boosting.",input$tipo.boosting,")))\n",
                    "scores[['ADA-BOOSTING - ",input$tipo.boosting,"']] <<- predict(modelo.boosting.",input$tipo.boosting,
                    ", datos.prueba[, -which(colnames(datos.prueba) == variable.predecir)], type = 'prob')\n```"))
      updatePlot$roc <- !updatePlot$roc #graficar otra vez la curva roc
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.boosting(2)
      showNotification(paste0("Error al ejecutar la prediccion boosting :",e), duration = 15, type = "error")
    }
    )
  }

  # Genera la matriz de confusion
  ejecutar.boosting.mc <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.b.mc)))
      output$txtBoostingMC <- renderPrint(exe("print(MC.boosting.",input$tipo.boosting,")"))

      exe(plot.MC.code())
      output$plot.boosting.mc <- renderPlot(exe("plot.MC(MC.boosting.",input$tipo.boosting,")"))

      insert.report(paste0("mc.b.",input$tipo.boosting), paste0("## Matriz de Confusión del Modelo ADA-BOOSTING - ",input$tipo.boosting,"\n```{r}\n",
                                                                cod.b.mc,"\nMC.boosting.",input$tipo.boosting,
                                                                "\n```\n\n```{r}\nplot.MC(MC.boosting.",input$tipo.boosting,")\n",
                                                                "MCs[['ADA-BOOSTING - ",input$tipo.boosting,"']] <<- MC.boosting.",input$tipo.boosting,"\n```"))

      MCs[[paste0("ADA-BOOSTING - ",input$tipo.boosting)]] <<- exe("MC.boosting.",input$tipo.boosting)
      actualizar.selector.comparativa()
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.boosting(3)
      showNotification(paste0("Error al ejecutar la matriz booting :",e), duration = 15, type = "error")
    }
    )
  }

  # Genera los indices
  ejecutar.boosting.ind <- function() {
    tryCatch({ # Se corren los codigo
      isolate(eval(parse(text = cod.b.ind)))

      MC <- exe("MC.boosting.",input$tipo.boosting)
      indices.boosting <<- indices.generales(MC)
      eval(parse(text = paste0("indices.boosting.",input$tipo.boosting, "<<- indices.boosting")))
      indices.g("boosting", MC)

      insert.report(paste0("ind.b.",input$tipo.boosting),
                    paste0("## Índices Generales del Modelo ADA-BOOSTING - ",input$tipo.boosting,"\n```{r}\n",
                           cod.b.ind, "\nindices.generales(MC.boosting.",input$tipo.boosting,")\n```"))
      nombres <- c("boostingPrecGlob", "boostingErrorGlob")
      titulos <- c("Precisión Global", "Error Global")

      fill.gauges(nombres, titulos, indices.boosting)

      # Cambia la tabla con la indices de boosting
      output$boostingIndPrecTable <- shiny::renderTable(xtable(indices.prec.table(indices.boosting,"ADA-BOOSTING")),
                                                        bordered = T, width = "100%", align = "c", digits = 2)

      output$boostingIndErrTable <- shiny::renderTable(xtable(indices.error.table(indices.boosting,"ADA-BOOSTING")),
                                                       bordered = T, width = "100%", align = "c", digits = 2)
    },
    error = function(e) { # Regresamos al estado inicial y mostramos un error
      limpia.boosting(4)
      showNotification(paste0("Error al ejecutar los indices booting :", e), duration = 15, type = "error")
    })
  }

  # TABLA COMPARATIVA -------------------------------------------------------------------------------------------------------

  #Actualiza los selectores de la tabla comparativa
  actualizar.selector.comparativa <- function(){
    shinyWidgets::updateCheckboxGroupButtons(session,"select.models",choices = sort(names(MCs)),selected = sort(names(MCs)),
                                             status = "primary",checkIcon = list(yes = icon("ok", lib = "glyphicon"),
                                                                                 no = icon("remove", lib = "glyphicon")))
  }

  # Crea la tabla comparativa
  tabla.comparativa <- function(sel) {
    tryCatch({
      cant.class <- length(unique(datos[, variable.predecir]))
      names.class <- as.character(unique(datos[, variable.predecir]))

      if(length(MCs) == 0) {
        return(data.frame())
      }

      matrices <- MCs[sort(names(MCs))]
      matrices <- matrices[names(matrices) %in% sel]
      df  <- data.frame()

      if(length(matrices) == 0) {
        return(data.frame())
      }

      for (i in seq_len(length(matrices))) {
        if (is.null(matrices[[i]])) {
          df <- rbind(df, c(names(matrices)[i], NA, rep(NA, cant.class), NA))
        } else {
          df <- rbind(df, c(NA,round((sum(diag(matrices[[i]])) / sum(matrices[[i]])) * 100, 4),
                            round(diag(matrices[[i]]) / rowSums(matrices[[i]]) * 100, 4),
                            ifelse(cant.class == 2,round(areas[[names(matrices)[i]]], 4), NA)))
          df[nrow(df),1] <- names(matrices)[i]
          names.class <- colnames(matrices[[i]])
        }
      }
      colnames(df) <- c('Modelo', 'Precisión Global', names.class, 'Área de ROC')
      return(df)
    }, error = function(e) {
      return(data.frame())
    })
  }

  # Calcula las areas de la curva roc de todos los modelos
  calcular.areas <- function(sel) {
    clase <- datos.prueba[, variable.predecir]
    if (length(unique(clase)) == 2) {
      for (nombre in names(scores)) {
        if (is.factor(scores[[nombre]])) {
          areas[[nombre]] <<- areaROC(attributes(scores[[nombre]])$probabilities[, sel], clase)
        }else{
          areas[[nombre]] <<- areaROC(scores[[nombre]][, which(levels(clase) == sel)], clase)
        }
      }
    }
  }

  #Hace el grafico de la curva roc
  output$plot.roc <- renderPlot({
    graficar <- updatePlot$roc
    if(!is.null(datos.prueba) & length(levels(datos[,variable.predecir])) == 2) {
      calcular.areas(input$roc.sel)
      insert.report("roc",paste0("## Curva ROC \n```{r}\ncalcular.areas('",input$roc.sel,"')\nplotROC( ",as.string.c(input$select.models)," )\n```"))
      plotROC(input$select.models)
    } else {
      insert.report("roc", NULL)
      showNotification("La curva ROC solo aplica para variables binarias.", duration = 15, type = "warning")
      return(NULL)
    }
  })

  #Muestra la tabla comparativa.
  output$TablaComp <- DT::renderDataTable({
    graficar <- updatePlot$roc
    if (!is.null(datos.aprendizaje)) {
      calcular.areas(input$roc.sel)
      insert.report("tabla.comparativa",paste0("## Tabla Comparativa \n```{r}\ncalcular.areas('",input$roc.sel,"')\ntabla.comparativa( ",
                                               as.string.c(input$select.models)," )\n```"))
      DT::datatable(tabla.comparativa(input$select.models),
                    selection = "none", editable = FALSE, extensions = c("Responsive"),
                    options = list(dom = "frtip", pageLength = 10, buttons = NULL))
    }
  },server = FALSE)

  #Si cambian los parametros
  observeEvent(c(input$select.models, input$roc.sel), {
    updatePlot$roc <- !updatePlot$roc
  })

  # PAGINA DE PREDICCIONES NUEVAS -------------------------------------------------------------------------------------------

  varificar.datos.pn <- function(){
    if(any(!(c(colnames(datos.prueba.completos),variable.predecir.pn) %in% colnames(datos.originales.completos))))
      stop("Los datos no poseen las mismas columnas")

  }

  unificar.factores <- function(){
    for(nombre in colnames(datos.prueba.completos)){
      if(class(datos.prueba.completos[,nombre]) == "factor"){
        levels(datos.prueba.completos[,nombre]) <<- unique(c(levels(datos.prueba.completos[,nombre]),
                                                            levels(datos.aprendizaje.completos[,nombre])))
      }
    }
  }

  actualizar.tabla.pn <- function(tablas = c("contentsPred", "contentsPred2")){
    if("contentsPred2" %in% tablas){
    output$contentsPred <- DT::renderDT(renderizar.tabla.datos(datos.aprendizaje.completos,
                                                               editable = F,
                                                               pageLength = 10,
                                                               buttons = F,
                                                               extensions = list(), dom = "frtip",
                                                               scrollY = "25vh"),
                                        server = F)
    }
    if("contentsPred2" %in% tablas){
    output$contentsPred2 <- DT::renderDT(renderizar.tabla.datos(datos.aprendizaje.completos,
                                                                editable = F,
                                                                pageLength = 10,
                                                                buttons = F,
                                                                extensions = list(), dom = "frtip",
                                                                scrollY = "25vh"),
                                         server = F)
    }
    if("contentsPred3" %in% tablas){
      output$contentsPred3 <- DT::renderDT(renderizar.tabla.datos(datos.prueba.completos,
                                                                  editable = F,
                                                                  pageLength = 10,
                                                                  buttons = F,
                                                                  extensions = list(), dom = "frtip",
                                                                  scrollY = "25vh"),
                                           server = T)
    }
  }

  actualizar.texto.modelo.pn <- function(codigo){
    updateAceEditor(session, "fieldPredNuevos", value = codigo)
    if(is.null(modelo.nuevos)){
      output$txtPredNuevos <- renderPrint(invisible(NULL))
    }else{
      output$txtPredNuevos <- renderPrint(print(modelo.nuevos))
    }
  }

  crear.datos.np <- function(){
    datos.aux.prueba <- datos.prueba.completos
    datos.aux.prueba[,variable.predecir.pn] <- predic.nuevos
    return(datos.aux.prueba)
  }

  actualizar.pred.pn <- function(codigo){
    updateAceEditor(session, "fieldCodePredPN", value = codigo)
    if(!is.null(predic.nuevos)){
      datos.aux.prueba <- crear.datos.np()
      output$PrediTablePN <- DT::renderDT(renderizar.tabla.datos(datos.aux.prueba,
                                                                  editable = F,
                                                                  pageLength = 10,
                                                                  buttons = F,
                                                                  dom = "frtip",
                                                                  scrollY = "25vh"),
                                           server = T)
    }else{
      output$PrediTablePN <- DT::renderDT(DT::datatable(data.frame()))
    }
  }

  output$downloaDatosPred <- downloadHandler(
    filename = function() {
      input$file3$name
    },
    content = function(file) {
      if(!is.null(predic.nuevos)){
        write.csv(crear.datos.np(), file, row.names = input$rownameNPred2)
      }
    }
  )

  observeEvent(input$loadButtonNPred,{
    codigo.carga <- code.carga( nombre.filas = input$rownameNPred,
                                ruta = input$file2$datapath,
                                separador = input$sepNPred,
                                sep.decimal = input$decNPred,
                                encabezado = input$headerNPred,
                                d.o = "datos.originales.completos",
                                d = "datos.aprendizaje.completos")

    tryCatch({
      isolate(eval(parse(text = codigo.carga)))
      if(ncol(datos.originales.completos) <= 1) {
        showNotification(paste0("Error al cargar los Datos: Revisar separadores"), duration = 10, type = "error")
        return(NULL)
      }
      codigo.na <- ""
      codigo.na <- paste0(code.NA(deleteNA = input$deleteNAnPred, d.o = "datos.originales.completos"), "\n", "datos.aprendizaje.completos <<- datos.originales.completos")
      isolate(eval(parse(text = codigo.na)))

      updateSelectInput(session, "sel.predic.var.nuevos", choices = rev(colnames.empty(var.categoricas(datos.aprendizaje.completos))))
      updateNumericInput(session, "kmax.knn.pred", value = round(sqrt(nrow(datos.aprendizaje.completos))))
      updateNumericInput(session, "mtry.rf.pred", value = round(sqrt(ncol(datos.aprendizaje.completos) -1)))
    },
    error = function(e) {
      showNotification(paste0("Error al cargar los Datos: ", e), duration = 10, type = "error")
      datos.aprendizaje.completos <<- NULL
      datos.originales.completos <<- NULL
      return(NULL)
    })

    modelo.nuevos <<- NULL
    predic.nuevos <<- NULL
    actualizar.pred.pn("")

    actualizar.texto.modelo.pn("")
    actualizar.tabla.pn()
  })

  update.trans.pn <- eventReactive(c(input$loadButtonNPred), {
    contadorPN <<- contadorPN + 1
    if (!is.null(datos.aprendizaje.completos) && ncol(datos.aprendizaje.completos) > 0) {
      res <- data.frame(Variables = colnames(datos.aprendizaje.completos),
                        Tipo = c(1:ncol(datos.aprendizaje.completos)),
                        Activa = c(1:ncol(datos.aprendizaje.completos)))
      res$Tipo <- sapply(colnames(datos.aprendizaje.completos), function(i) paste0(
        '<select id="Predsel', i, contadorPN, '"> <option value="categorico">Categórico</option>
        <option value="numerico" ', ifelse(class(datos.aprendizaje.completos[, i]) %in% c("numeric", "integer"),
                                           ' selected="selected"', ""
      ),
      '>Numérico</option> <option value="disyuntivo">Disyuntivo</option> </select>'
      ))
      res$Activa <- sapply(colnames(datos.aprendizaje.completos), function(i) paste0('<input type="checkbox" id="Predbox', i, contadorPN, '" checked/>'))
    } else {
      res <- as.data.frame(NULL)
      showNotification("Tiene que cargar los datos", duration = 10, type = "error")
    }
    return(res)
  })

  output$transDataPredN <- DT::renderDataTable(update.trans.pn(),
                                          escape = FALSE, selection = "none", server = FALSE,
                                          options = list(dom = "t", paging = FALSE, ordering = FALSE, scrollY = "35vh"), rownames = F,
                                          callback = JS("table.rows().every(function(i, tab, row) {
                                                        var $this = $(this.node());
                                                        $this.attr('id', this.data()[0]);
                                                        $this.addClass('shiny-input-checkbox');});
                                                        Shiny.unbindAll(table.table().node());
                                                        Shiny.bindAll(table.table().node());"))

  transformar.datos.pn <- function() {
    var.noactivas <- c()
    code.res <- "datos.aprendizaje.completos <<- datos.originales.completos \n"
    for (var in colnames(datos.originales.completos)) {
      if (input[[paste0("Predbox", var, contadorPN)]]) {
        if (input[[paste0("Predsel", var, contadorPN)]] == "categorico" & class(datos.originales.completos[, var]) %in% c("numeric", "integer")) {
          code.res <- paste0(code.res, code.trans(var, "categorico", d.o = "datos.originales.completos", d = "datos.aprendizaje.completos" ), "\n")
        }
        if (input[[paste0("Predsel", var, contadorPN)]] == "numerico" & !(class(datos.originales.completos[, var]) %in% c("numeric", "integer"))) {
          code.res <- paste0(code.res, code.trans(var, "numerico",  d.o = "datos.originales.completos", d = "datos.aprendizaje.completos" ), "\n")
        }
        if (input[[paste0("Predsel", var, contadorPN)]] == "disyuntivo") {
          code.res <- paste0(code.res, code.trans(var, "disyuntivo", d.o = "datos.originales.completos", d = "datos.aprendizaje.completos" ), "\n")
        }
      } else {
        var.noactivas <- c(var.noactivas, var)
      }
    }


    isolate(eval(parse(text = code.res)))
    if (length(var.noactivas) > 0) {
      des <- code.desactivar(var.noactivas,"datos.aprendizaje.completos")
      isolate(eval(parse(text = des)))
      code.res <- paste0(code.res, "\n", des)
    }
    code.res <- paste0(code.res, "\n")
    return(code.res)
  }

  predecir.pn <-function(){
    codigo <- switch(modelo.seleccionado.pn,
                     knn =  kkn.prediccion.pn(),
                     dt  = dt.prediccion.np(),
                     rf  = rf.prediccion.np(),
                     ada = boosting.prediccion.np(),
                     svm = svm.prediccion.np())
    tryCatch({
      eval(parse(text = codigo))
      actualizar.pred.pn(codigo)
    },
    error =  function(e){
      showNotification(paste0("Error en la predicción: ", e), duration = 10, type = "error")
    })
  }

  observeEvent(input$transButtonPredN, {
    # transforma los datos
    code.trans.pn <<- transformar.datos.pn()

    # Actualiza los selectores que dependen de los datos
    updateSelectInput(session, "sel.predic.var.nuevos", choices = rev(colnames.empty(var.categoricas(datos.aprendizaje.completos))))
    updateNumericInput(session, "mtry.rf.pred", value = round(sqrt(ncol(datos.aprendizaje.completos) -1)))

    modelo.nuevos <<- NULL
    predic.nuevos <<- NULL
    actualizar.pred.pn("")

    actualizar.texto.modelo.pn("")
    actualizar.tabla.pn()
  })

  observeEvent(input$PredNuevosBttnModelo,{
    codigo <- switch(input$selectModelsPred,
                     knn =  kkn.modelo.np(variable.pr = input$sel.predic.var.nuevos,
                                          scale = input$switch.scale.knn.pred,
                                          kmax = input$kmax.knn.pred,
                                          kernel = input$kernel.knn.pred),
                     dt  = dt.modelo.np(variable.pr = input$sel.predic.var.nuevos,
                                        minsplit = input$minsplit.dt.pred,
                                        maxdepth = input$maxdepth.dt.pred,
                                        split = input$split.dt.pred),
                     rf  = rf.modelo.np(variable.pr = input$sel.predic.var.nuevos,
                                        ntree = input$ntree.rf.pred,
                                        mtry = input$mtry.rf.pred),
                     ada = boosting.modelo.np(variable.pr = input$sel.predic.var.nuevos,
                                              iter = input$iter.boosting.pred,
                                              maxdepth = input$maxdepth.boosting.pred,
                                              type = input$tipo.boosting.pred,
                                              minsplit = input$minsplit.boosting.pred),
                     svm = svm.modelo.np(variable.pr =input$sel.predic.var.nuevos,
                                         scale = input$switch.scale.svm.pred,
                                         kernel = input$kernel.svm.pred))
      variable.predecir.pn <<- input$sel.predic.var.nuevos
      modelo.seleccionado.pn  <<- input$selectModelsPred
      modelo.nuevos <<- NULL
      predic.nuevos <<- NULL
      actualizar.pred.pn("")

      tryCatch({
        eval(parse(text = codigo))
        actualizar.texto.modelo.pn(codigo)
      },
      error =  function(e){
        showNotification(paste0("Error en el modelo: ", e), duration = 10, type = "error")
      })
  })

  observeEvent(input$loadButtonNPred2,{
    codigo.carga <- code.carga( nombre.filas = input$rownameNPred2,
                                ruta = input$file3$datapath,
                                separador = input$sep.nPred2,
                                sep.decimal = input$dec.nPred2,
                                encabezado = input$headerNPred2,
                                d.o = "datos.prueba.completos",
                                d = "datos.prueba.completos")

    tryCatch({
      isolate(eval(parse(text = codigo.carga)))
      varificar.datos.pn()
      if(ncol(datos.prueba.completos) <= 1) {
        showNotification(paste0("Error al cargar los Datos: Revisar separadores"), duration = 10, type = "error")
        return(NULL)
      }
      codigo.na <- ""
      codigo.na <- paste0(code.NA(deleteNA = input$deleteNAnPred2,
                                  d.o = paste0("datos.prueba.completos")))
      datos.prueba.completos[,variable.predecir.pn] <<- NULL
      isolate(eval(parse(text = codigo.na)))
      datos.prueba.completos[,variable.predecir.pn] <<- NA
      code.trans.pn <<- gsub("datos.originales.completos", "datos.prueba.completos", code.trans.pn)
      code.trans.pn <<- gsub("datos.aprendizaje.completos", "datos.prueba.completos", code.trans.pn)
      exe(code.trans.pn)
      unificar.factores()
      actualizar.tabla.pn("contentsPred3")
      predecir.pn()
    },
    error = function(e) {
      showNotification(paste0("Error al cargar los Datos: ", e), duration = 10, type = "error")
      datos.prueba.completos <<- NULL
      predic.nuevos <<- NULL
      return(NULL)
    })
  })

  # PAGINA DE REPORTE -------------------------------------------------------------------------------------------------------

  len.report <- function(){
    length(env.report$codigo.reporte)
  }

  insert.report <- function(id, content, interpretation =  TRUE){
    n <- len.report()
    if(is.null(content)){
      env.report$codigo.reporte[[n]][[id]] <<- content
    }else{
      env.report$codigo.reporte[[n]][[id]] <<- ifelse(interpretation, paste0(content,"\n\n#### Interpretación\n\n"), content)
    }
  }

  names.report <- function(){
    n <- len.report()
    names(env.report$codigo.reporte[[n]])
  }

  new.report <- function(){
    n <- len.report() + 1
    env.report$codigo.reporte[[n]] <<- list(datos.originales = datos.originales)
    env.report$codigo.reporte[[n]][["carga.datos"]] <<- paste0("\n# Carga de Datos (",input$file1$name,")",
                                                    "\n```{r}\ndatos.originales <<- codigo.reporte[[",n,"]]$datos.originales\n",
                                                    "datos <<- datos.originales\n```\n```{r}\nhead(datos)\n```\n```{r}\nstr(datos)\n```\n",
                                                    "```{r}\nMCs <<- list()\nareas <<- list()\nscores <<- list()\n```\n")
  }

  new.secction.report <- function(){
    n <- len.report() + 1
    env.report$codigo.reporte[[n]] <<- list()
  }

  observeEvent(input$principal, {
    if(input$principal == "reporte"){
      updateAceEditor(session, "fieldCodeReport", value = def.reporte(titulo = input$textTitulo, nombre = input$textNombre, input))
    }
  })

  observeEvent(input$textTitulo, {
    updateAceEditor(session, "fieldCodeReport", value = str_replace(input$fieldCodeReport, "title: '.*'", paste0("title: '", input$textTitulo, "'")))
  })

  observeEvent(input$textNombre, {
    updateAceEditor(session, "fieldCodeReport", value = str_replace(input$fieldCodeReport, "author: '.*'", paste0("author: '", input$textNombre, "'")))
  })

  output$descargar <- downloadHandler(
    filename = function() {
      paste(input$textTitulo,'-', input$textNombre, '.zip', sep='')
    },
    content = function(file) {
      owd <- setwd(tempdir())
      on.exit(setwd(owd))
      files <- NULL

      namermd <- paste(input$textTitulo,'-', input$textNombre, '.rmd', sep='')
      writeLines(input$fieldCodeReport, namermd)
      files <- c(namermd, files)

      src <- normalizePath(namermd)
      withCallingHandlers({
        overwrite.cat()
        salida.code <<- ""
        shinyjs::html("txtreport", salida.code)
        out <- rmarkdown::render(src,  params = NULL, rmarkdown::word_document(highlight = "tango"), envir = env.report)
      },
      message = function(m) {
        salida.code <<- paste0(m$message, salida.code)
        shinyjs::html(id = "txtreport", html = salida.code)
      })

      recover.cat()
      file.rename(out, paste(input$textTitulo,'-', input$textNombre, '.docx', sep=''))
      files <- c(paste(input$textTitulo,'-', input$textNombre, '.docx', sep=''), files)

      zip::zip(file, files)
    }
  )

  # Termina la Sesion -------------------------------------------------------------------------------------------------------

  session$onSessionEnded(function() {
    rm(envir = .GlobalEnv, list = ls(envir = .GlobalEnv))
    unlink("figure", recursive = T)
    stopApp()
  })

})
